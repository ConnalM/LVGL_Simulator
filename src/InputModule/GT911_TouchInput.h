#pragma once

#include "InputModule.h"       // From Display4 framework
#include "InputCommand.h"      // From Display4 framework
#include "common/Types.h"        // For InputEvent, InputSourceId
#include "common/TimeManager.h"  // For TimeManager
#include <lvgl.h>
#ifndef SIMULATOR
#include <TAMC_GT911.h>        // Touch driver library
#else
// Dummy touch controller for simulator
class TAMC_GT911_Dummy {
public:
    // Dummy touch point structure
    struct TouchPoint {
        int16_t x;
        int16_t y;
    };
    
    // Dummy touch controller properties
    bool isTouched = false;
    TouchPoint points[5]; // Support up to 5 touch points like GT911
    
    // Dummy methods
    void begin() {}
    void read() {}
    void setRotation(int rotation) {}
};
#endif
#include <queue>               // For std::queue

// Define touch controller pins based on ESP32-8048S070 (from Display5_TouchTest/src/touch.h)
// These should ideally come from a board-specific config file or be passed to constructor
#define TOUCH_GT911_SDA 19  // From Display5 touch.h (was 38)
#define TOUCH_GT911_SCL 20  // From Display5 touch.h (was 39)
#define TOUCH_GT911_INT 17  // From Display5 touch.h (was -1)
#define TOUCH_GT911_RST 18  // From Display5 touch.h (was -1)

// Touch panel resolution (GT911 typically has a fixed resolution)
#define TOUCH_PANEL_WIDTH   800
#define TOUCH_PANEL_HEIGHT  480

// Touch screen calibration and orientation for ESP32-8048S070 (800x480)
// These values define the mapping of touch coordinates
#define TOUCH_MAP_X1 0     // Left edge of touch area
#define TOUCH_MAP_X2 800   // Right edge of touch area
#define TOUCH_MAP_Y1 0     // Top edge of touch area
#define TOUCH_MAP_Y2 480   // Bottom edge of touch area

class GT911_TouchInput : public InputModule {
public:
    GT911_TouchInput();
    virtual ~GT911_TouchInput();

    /**
     * @brief Initializes the GT911 touch controller and LVGL input device.
     * @return true if initialization was successful, false otherwise.
     */
    bool initializeInput();

    // Inherited from InputModule
    /**
     * @brief Polls for an InputEvent from the queued LVGL interactions.
     * @param event Reference to an InputEvent structure to be filled.
     * @return true if an event was available and dequeued, false otherwise.
     */
    virtual bool poll(InputEvent& event) override;

    /**
     * @brief LVGL input device read callback.
     * Reads touch data from GT911 and reports it to LVGL.
     * @param indev_drv Pointer to the LVGL input device driver.
     * @param data Pointer to the LVGL input data structure to be filled.
     */
    static void lvgl_touch_read_cb(lv_indev_drv_t *indev_drv, lv_indev_data_t *data);

    /**
     * @brief Queues a system-level InputEvent generated from an LVGL widget interaction.
     * This static method is called by LVGL event callbacks (likely in the DisplayDriver code).
     * @param sysEvent The InputEvent to queue.
     */
    static void queueSystemInputEvent(const InputEvent& sysEvent);

private:
#ifdef SIMULATOR
    TAMC_GT911_Dummy* _touchController; // Use the dummy class for simulator
#else
    TAMC_GT911* _touchController;       // Instance of the touch controller
#endif
    static lv_indev_t* _lvglInputDevice; // LVGL input device for touch

    // Queue for InputEvents generated by LVGL widget callbacks
    static std::queue<InputEvent> _inputEventQueue;

    // Last touch coordinates (raw, for LVGL)
    static int16_t _lastTouchX;
    static int16_t _lastTouchY;
    static lv_indev_state_t _lastTouchState;

    // Touch state tracking with validation
    static constexpr int16_t TOUCH_DEADZONE = 5;  // Deadzone for touch release detection
    static constexpr int16_t MIN_TOUCH_X = 0;
    static constexpr int16_t MAX_TOUCH_X = TOUCH_PANEL_WIDTH - 1;
    static constexpr int16_t MIN_TOUCH_Y = 0;
    static constexpr int16_t MAX_TOUCH_Y = TOUCH_PANEL_HEIGHT - 1;

    /**
     * @brief Validates touch coordinates against screen bounds
     * @param x X coordinate to validate
     * @param y Y coordinate to validate
     * @return true if coordinates are within valid range, false otherwise
     */
    bool validateTouchCoordinates(int16_t& x, int16_t& y) const;

    /**
     * @brief Clamps a value between min and max
     * @tparam T Type of the value
     * @param value Value to clamp
     * @param min Minimum allowed value
     * @param max Maximum allowed value
     * @return Clamped value
     */
    template<typename T>
    static T clamp(T value, T min, T max) {
        return (value < min) ? min : (value > max) ? max : value;
    }

    // Helper to read from GT911 and update static members for lvgl_touch_read_cb
    void readRawTouch(); 
};
